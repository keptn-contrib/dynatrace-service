name: CI
on:
  # always execute docker build when something is pushed to master or release-* branches
  push:
    branches:
      - 'master'
      - 'release-*'
  # in addition, execute for pull requests to those branches
  pull_request:
    branches:
      - 'master'
      - 'release-*'
defaults:
  run:
    shell: bash
jobs:
  prepare_ci_run:
    name: Prepare CI Run
    # Prepare CI Run looks at what has been changed in this commit/PR/... and determines which artifacts should be
    # built afterwards (in other jobs that depend on this one).
    runs-on: ubuntu-20.04
    outputs: # declare what this job outputs (so it can be re-used for other jobs)
      # build config
      # metadata
      GIT_SHA: ${{ steps.extract_branch.outputs.GIT_SHA }}
      BRANCH: ${{ steps.extract_branch.outputs.BRANCH }}
      BRANCH_SLUG: ${{ steps.extract_branch.outputs.BRANCH_SLUG }}
      VERSION: ${{ steps.get_version.outputs.VERSION }}
      DATE: ${{ steps.get_datetime.outputs.DATE }}
      TIME: ${{ steps.get_datetime.outputs.TIME }}
      DATETIME: ${{ steps.get_datetime.outputs.DATETIME }}

    steps:
      - name: Check out code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0 # need to checkout "all commits" for certain features to work (e.g., get all changed files)

      - name: Load CI Environemnt from .ci_env
        id: load_ci_env
        uses: c-py/action-dotenv-to-setenv@v2
        with:
          env-file: .ci_env

      - name: Extract branch name
        id: extract_branch
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads"* ]]; then
            echo "This is a push to a local branch -> using branch name"
            BRANCH=${GITHUB_REF#refs/heads/}
            BRANCH_SLUG=$(echo $BRANCH | iconv -t ascii//TRANSLIT | sed -r s/[^a-zA-Z0-9]+/-/g | sed -r s/^-+\|-+$//g | tr A-Z a-z)
          else
            if [[ "${GITHUB_REF}" == "refs/pull/"* ]]; then
              # usually the format for PRs is: refs/pull/1234/merge
              echo "This is a Pull Request -> using PR ID"
              tmp=${GITHUB_REF#refs/pull/}
              # remove the last "/merge"
              # Branch name is basically the PR id
              BRANCH=${tmp%/merge}
              # And Slug is "PR-${PRID}"
              BRANCH_SLUG=PR-${BRANCH}
            else
              echo "::error This is neither a push, nor a PR, probably something else... Exiting"
              exit 1
            fi
          fi

          GIT_SHA="$(git rev-parse --short HEAD)"

          # print GIT_SHA, BRANCH and BRANCH_SLUG (make sure they are also set in needs.prepare_ci_run.outputs !!!)
          echo "##[set-output name=BRANCH;]$(echo ${BRANCH})"
          echo "##[set-output name=BRANCH_SLUG;]$(echo ${BRANCH_SLUG})"
          echo "##[set-output name=GIT_SHA;]$(echo ${GIT_SHA})"
      - name: 'Get Previous tag'
        id: get_previous_tag
        uses: "WyriHaximus/github-action-get-previous-tag@1.0.0"
      - name: 'Get next patch version'
        id: get_next_semver_tag
        uses: "WyriHaximus/github-action-next-semvers@v1"
        with:
          version: ${{ steps.get_previous_tag.outputs.tag }}
      - name: Get the version
        id: get_version
        env:
          BRANCH: ${{ steps.extract_branch.outputs.BRANCH }}
          BRANCH_SLUG: ${{ steps.extract_branch.outputs.BRANCH_SLUG }}
        shell: bash
        run: |
          # determine version
          GIT_LAST_TAG=${{ steps.get_previous_tag.outputs.tag }}
          GIT_NEXT_TAG=${{ steps.get_next_semver_tag.outputs.patch }}
          echo "GIT_LAST_TAG=${GIT_LAST_TAG}, GIT_NEXT_TAG=${GIT_NEXT_TAG}"

          if [[ "$BRANCH" == "release-"* ]]; then
            # Release Branch: extract version from branch name
            VERSION=${BRANCH#"release-"}
            else
            if [[ "$BRANCH" == "master" ]]; then
              # master branch = latest
              VERSION="${GIT_NEXT_TAG}-dev"
            else
              # Feature/Development Branch - use last tag with branch slug
              VERSION="${GIT_NEXT_TAG}-dev-${BRANCH_SLUG}"
            fi
          fi

          echo "VERSION=${VERSION}"

          echo "##[set-output name=VERSION;]$(echo ${VERSION})"
      - name: Get current date and time
        id: get_datetime
        run: |
          echo "::set-output name=DATE::$(date +'%Y%m%d')"
          echo "::set-output name=TIME::$(date +'%H%M')"
          echo "::set-output name=DATETIME::$(date +'%Y%m%d')$(date +'%H%M')"

  ############################################################################
  # Unit tests                                                               #
  ############################################################################
  unit-tests:
    name: Unit Tests
    needs: prepare_ci_run
    runs-on: ubuntu-20.04
    steps:
      - name: Set up Go 1.x
        uses: actions/setup-go@v2
        with:
          go-version: ^1.13
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Load CI Environemnt from .ci_env
        id: load_ci_env
        uses: c-py/action-dotenv-to-setenv@v2
        with:
          env-file: .ci_env

      - name: Test
        run: go test -coverprofile=coverage.txt -covermode=atomic -v ./...
        working-directory: .


  ############################################################################
  # Build Docker Image                                                      #
  ############################################################################
  docker_build:
    needs: [prepare_ci_run, unit-tests]
    name: Docker Build
    runs-on: ubuntu-20.04
    env:
      BRANCH: ${{ needs.prepare_ci_run.outputs.BRANCH }}
      VERSION: ${{ needs.prepare_ci_run.outputs.VERSION }}
      DATETIME: ${{ needs.prepare_ci_run.outputs.DATE }}${{ needs.prepare_ci_run.outputs.TIME }}
      GIT_SHA: ${{ needs.prepare_ci_run.outputs.GIT_SHA }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Load CI Environemnt from .ci_env
        id: load_ci_env
        uses: c-py/action-dotenv-to-setenv@v2
        with:
          env-file: .ci_env

      - id: docker_login
        name: Docker Login
        env:
          REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
        run: echo "$REGISTRY_PASSWORD" | docker login --username $REGISTRY_USER --password-stdin

      - id: prepare_manifest
        name: Prepare Build Manifest
        run: |
          ./docker/writeManifest.sh
          cat ./docker/MANIFEST

      - id: docker_build
        name: Docker Build service
        env:
          IMAGE: "${{ env.DOCKER_ORGANIZATION }}/${{ env.IMAGE }}"
        run: |
          ./gh-actions-scripts/build_docker_image.sh "${IMAGE}" "${GIT_SHA}" "${VERSION}" "${DATETIME}"
